Основная проблема — несколько клиентов могут одновременно          бронировать один и тот же рейс или транспорт. Решали это так:
	1.     **Блокировка на уровне базы (pessimistic lock)** – В критичных местах использовали SELECT ... FOR UPDATE, чтобы один процесс заблокировал заказ, пока его оформляет.
	2.     **Optimistic locking** – Если конкуренция не такая жёсткая, добавляли версионное поле (version), и перед обновлением проверяли, не изменились ли данные.
	3.     **Redis с TTL** – Когда надо было быстро заблокировать место, использовали Redis: при запросе бронирования писали ключ order:{id} с небольшим TTL (например, 30 секунд), чтобы временно зарезервировать заказ.
	4.     **Очередь сообщений (Kafka, но редко)** – В некоторых сервисах, где заказы шли с большой нагрузкой, просто писали их в Kafka, а обработчик по очереди принимал и сохранял в базу.
	5.     **Rate Limiting** – Если приходило слишком много запросов от одного пользователя, могли ограничивать их частоту (например, не больше 5 бронирований в секунду).

Конкретный пример:  
Была проблема, когда два водителя одновременно брали один и тот же      груз в рейсах. Решили через Redis-блокировку с TTL: как только        водитель нажимал "Взять рейс", в Redis писался ключ trip:{id}. Второй водитель получал ошибку "Рейс уже занят".