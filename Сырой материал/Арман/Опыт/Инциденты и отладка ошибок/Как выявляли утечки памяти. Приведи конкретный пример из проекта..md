В одном из проектов столкнулись с утечкой памяти в микросервисе,    который занимался обработкой GPS-данных. Он постоянно держал в       памяти данные об активных сессиях трекеров, но при завершении           сессии эти объекты не освобождались, что приводило к росту             потребления памяти и, в конечном итоге, OutOfMemoryError.

**Как выявили:**
	1.     **Мониторинг метрик в Grafana**: заметили, что потребление памяти постоянно растёт, даже когда нагрузка на сервис снижается.
	2.     **Heap dump через VisualVM**: сделали дамп памяти и посмотрели, какие объекты занимают больше всего места.
	3.     **Анализ в Eclipse MAT**: увидели, что коллекция ConcurrentHashMap<TrackerId, SessionData> продолжает расти, а объекты SessionData не удаляются.
	4.     **Проверка кода**: оказалось, что данные о сессиях хранились в Map, но не удалялись при завершении сессии, из-за чего GC их не мог собрать.

**Как исправили:**
	·        Добавили механизм очистки сессий по таймауту с использованием ScheduledExecutorService.
	·        Перешли на **WeakReference** для объектов, которые не должны жить в памяти дольше, чем их активное использование.
	·        Добавили алерты на аномальное потребление памяти, чтобы не допустить повторения ситуации.

После исправления утечка пропала, а потребление памяти стабилизировалось.