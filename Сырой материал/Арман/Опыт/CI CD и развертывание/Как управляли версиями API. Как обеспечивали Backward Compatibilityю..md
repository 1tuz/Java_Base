Версии API управляли **следующими способами**:
	**1. Версионирование API**
            Использовали **URI-версионирование** (/api/v1/...), чтобы клиенты               явно указывали, какую версию API они используют.                   
            Пример:
		·        GET /api/v1/users — первая версия
		·        GET /api/v2/users — вторая версия с измененной структурой
	2. Backward Compatibility (Совместимость с прошлыми версиями)**
		Чтобы старые клиенты не ломались после обновления, следовали               принципам:
		·  **Добавляли новые поля, но не удаляли старые** (клиенты просто их                                               игнорировали).
		·   **Меняли логику в новых версиях API**, не затрагивая старые (`v1` работал как                      раньше, `v2` — с улучшениями).
		·  **Использовали feature flags** — включали новую функциональность для части                            клиентов, а не сразу для всех.
	**3. API Gateway**
         Пропускали запросы через **API Gateway**, который мог:
		·        Маршрутизировать трафик на нужную версию API
		·        Конвертировать старые запросы в новый формат
	4. Документация и Deprecation Policy
	·        В **Swagger/OpenAPI** отмечали устаревшие поля и версии.
	·       Старые версии не выключали резко, а предупреждали за **несколько месяцев** до их отключения.

Использовали **версионирование через URI**, поддерживали обратную          совместимость и           давали клиентам время на миграцию.