При обнаружении критических ошибок в новой версии использовали         **несколько стратегий отката**, в зависимости от ситуации.
1. Быстрый откат (Rollback) через CI/CD
	·        В GitLab CI/CD или Jenkins хранили предыдущие стабильные артефакты.
	·        В случае проблемы просто перекатывались на предыдущий релиз (git revert, helm rollback, kubectl rollout undo).

      Когда использовали: если баг критичный, ломает ключевой      функционал.

2. Feature Flags
	·         Новую логику включали через флаги (например, Unleash, LaunchDarkly).
	·         Если ошибка — просто отключали фичу без отката версии.

    Когда использовали: если баг в новой фиче, но сервис в целом          работает.

3. Blue-Green Deployment
	·         Было два окружения (синее и зеленое), трафик направляли на одно из них.
	·         Если баг — быстро переключали трафик обратно на старую версию.

    Когда использовали: при обновлениях, где нельзя терять доступность.

4. Canary Deployment
	·         Новую версию сначала катили на 5-10% пользователей.
	·         Если метрики ухудшались (увеличение 500-ок, падение RPS) — откат до старой версии.

   Когда использовали: при сложных обновлениях, где нужен      контрольный запуск.

Как мониторили ошибки?
	·         Grafana + Prometheus — следили за метриками (latency, ошибки 5xx).
	·         ELK (Elasticsearch, Logstash, Kibana) — анализ логов.
	·         Sentry — алерты на критические ошибки.

В зависимости от ситуации использовали rollback, feature flags, Blue- Green или Canary.