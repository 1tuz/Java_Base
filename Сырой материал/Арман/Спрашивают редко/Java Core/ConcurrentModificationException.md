**ConcurrentModificationException** — это исключение, которое выбрасывается, когда мы пытаемся изменить коллекцию, пока мы её итерируем с помощью итератора или цикла.

Когда возникает:
1. Когда коллекция **fail-fast** (например, `ArrayList`, `HashMap`) изменяется (добавляется или удаляется элемент) после того, как вы создали итератор или начали итерацию.
2. Коллекция не позволяет одновременно итерировать и модифицировать себя, чтобы избежать ошибок или некорректного поведения.

Как это работает:
Коллекции, такие как `ArrayList` или `HashMap`, используют внутренний счётчик изменений (например, `modCount`)
1. Когда мы создаём итератор, он запоминает текущее значение этого счётчика.
2. Если счётчик изменений изменился (например, мы добавили, удалили или изменили элемент), итератор понимает, что коллекция модифицировалась, и выбрасывает исключение `ConcurrentModificationException`.

Как избежать:
1. Использовать `Iterator` для удаления элементов
2. **Использовать коллекции из `java.util.concurrent`:** Эти коллекции (например, `ConcurrentHashMap`, `CopyOnWriteArrayList`) поддерживают fail-safe поведение
3. Избегать изменения коллекции во время итерации:
	1) Сначала собрать все элементы для изменения в отдельный список.
	2) После завершения итерации модифицировать коллекцию.

Ключевая идея:
`ConcurrentModificationException` помогает нам не запутаться в ситуации, когда мы одновременно итерируем и изменяем коллекцию, предотвращая ошибки и неожиданные результаты.