**Mapped Superclass** в JPA — это специальный тип базового класса, который содержит общие для нескольких сущностей (Entity) поля, но сам не является сущностью и не сопоставляется с таблицей в базе данных.

Основные особенности:
1. **Не создаёт таблицу в базе данных**: 
   Класс с аннотацией **@MappedSuperclass** не сопоставляется с отдельной таблицей.
2. **Поля наследуются потомками**: 
   Все поля и аннотации из класса **@MappedSuperclass** включаются в таблицы дочерних сущностей.
3. **Не используется напрямую**: 
   Нельзя использовать `EntityManager` для работы с объектами класса **@MappedSuperclass**.

Когда использовать:
Когда несколько сущностей имеют общие поля (например, ID, даты создания и обновления), и вы хотите избежать дублирования кода.

Ограничения:
1. **Не является сущностью**: Нельзя сохранять или извлекать объекты **@MappedSuperclass** напрямую.
2. **Только для общих данных**: Подходит, если базовый класс содержит только данные, общие для всех потомков. Если нужно добавить логику, лучше использовать другие механизмы (например, наследование с стратегией JPA).

Зачем нужен **@MappedSuperclass**, если уже есть наследование:
Сопоставление с БД (JPA специфичность):
1. **Без @MappedSuperclass**: Если вы просто унаследуете сущности от базового класса, JPA не будет знать, что поля базового класса должны быть частью таблицы дочерних сущностей.
2. **С @MappedSuperclass**: JPA "видит" поля базового класса и автоматически включает их в таблицы дочерних сущностей, экономя вам время на настройку.

Отличия от обычного наследования:
1. **Отсутствие отдельной таблицы для базового класса**:
	1) Если бы вы использовали обычное наследование с аннотацией **@Entity** для базового класса, JPA создало бы отдельную таблицу для него.
	2) **С @MappedSuperclass** таблица для базового класса не создаётся, а его поля добавляются в таблицы дочерних сущностей.
2. **Работа только с дочерними классами**:
	1) Объекты базового класса нельзя использовать в JPA напрямую. Вы не можете сохранять или извлекать экземпляры базового класса — только экземпляры дочерних классов.
3. **Повторное использование общих полей**:
	1) **С @MappedSuperclass**: Поля можно использовать в нескольких сущностях без создания лишних таблиц.
	2) **Без @MappedSuperclass**: Придётся копировать аннотации и логику в каждый класс.

Почему это удобно:
1. **Оптимизация структуры базы данных**:
	1) Не нужно создавать лишние таблицы (как при обычном наследовании).
	2) Поля из базового класса сразу добавляются в дочерние сущности.
2. **Гибкость для общей логики**:
   Вы можете использовать базовый класс для описания полей, которые точно должны быть у нескольких сущностей, но которые не имеют смысла как самостоятельная таблица.
3. **Экономия кода**:
   Не нужно копировать аннотации и общие поля в каждую сущность.

В чём разница с обычным наследованием:
Если бы мы использовали обычное наследование без **@MappedSuperclass**, нам пришлось бы вручную настраивать, какие поля включать в дочерние сущности, и столкнулись бы с избыточностью в структуре базы данных.