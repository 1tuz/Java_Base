Аннотации **@Embedded** и **@Embeddable** в JPA используются для работы с **вложенными объектами** (или компонентами) в сущностях. Они помогают вам разбивать сущности на логически связанные группы полей, сохраняя их в одной таблице.

Объяснение простыми словами:
1. **@Embeddable**:
	1) Это аннотация, которую вы добавляете к классу, чтобы указать, что он будет использоваться как вложенный объект внутри другой сущности.
	2) Такой класс **не является отдельной сущностью** и не имеет своей таблицы в базе данных.
	3) Поля этого класса "встраиваются" в таблицу родительской сущности.
2. **@Embedded**:
   Это аннотация, которую вы добавляете в родительскую сущность, чтобы указать, что данный объект (с аннотацией **@Embeddable**) нужно встроить в таблицу этой сущности.

Зачем это нужно:
1. **Упрощение структуры кода**:
	1) Поля, которые логически связаны друг с другом (например, поля адреса), можно сгруппировать в отдельный класс.
	2) Код становится чище и понятнее.
2. **Повторное использование**:
   Если другие сущности (например, **Company**) тоже используют адрес, можно повторно использовать класс `Address` без копирования полей.
3. **Читаемость в базе данных**:
   Поля компонента хранятся в той же таблице, что и родительская сущность. Это упрощает структуру БД.

Дополнительные особенности:
Можно использовать **@AttributeOverrides** для переопределения названий колонок, если один и тот же компонент используется в нескольких местах.

@Entity
public class Company {
    @Id
    @GeneratedValue
    private Long id;
    private String name;

    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "street", column = @Column(name = "office_street")),
        @AttributeOverride(name = "city", column = @Column(name = "office_city")),
        @AttributeOverride(name = "zipCode", column = @Column(name = "office_zip"))
    })
    private Address officeAddress;

    // Геттеры и сеттеры
}

Разница между **@MappedSuperclass** и **@Embedded/@Embeddable**
![[Pasted image 20241226172728.png]]

Зачем использовать **@Embedded/@Embeddable**, если есть **@MappedSuperclass**:
1. Композиция вместо наследования:
	1) **@MappedSuperclass** работает через наследование, а **@Embedded/@Embeddable** — через включение объекта.
	2) Если ваши сущности логически **не должны быть связаны через "extends"**, вы используете **@Embedded/@Embeddable**.
2. Повторное использование без ограничения архитектуры:
	1) **@MappedSuperclass** "жёстко" связывает сущности через наследование.
	2) **@Embedded/@Embeddable** позволяет вставить одни и те же поля в несколько сущностей, даже если они совершенно разные.
3. Избегание слишком глубокой иерархии:
	1) Наследование через **@MappedSuperclass** может быть полезным, но злоупотребление им может привести к сложной иерархии, что снижает гибкость.
4. Группировка полей:
	1) Если у вас есть логически связанная группа полей, удобнее использовать **@Embedded/@Embeddable**, чтобы подчеркнуть связь между ними.

Когда выбрать что:
1. Если вам нужны **общие поля и методы** в сущностях, используйте **@MappedSuperclass**.
2. Если вы хотите **группировать логически связанные поля**, используйте **@Embedded/@Embeddable**.