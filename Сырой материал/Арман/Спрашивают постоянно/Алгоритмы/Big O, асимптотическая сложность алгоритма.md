Когда мы пишем программы, важно понимать, насколько **быстро** они работают и сколько **памяти** используют, особенно когда данные увеличиваются. **Big O** помогает нам оценить эффективность алгоритма, показывая, как меняется его производительность при увеличении входных данных.

Что показывает Big O:
1. **Скорость работы алгоритма:** Сколько операций нужно выполнить, чтобы решить задачу
2. **Используемая память:** Сколько памяти потребляет алгоритм

Big O выражает это с помощью простых математических функций, таких как O(1),O(n),O(n2)O(1), O(n), O(n^2)O(1),O(n),O(n2), где: n — это размер входных данных.

Основные типы сложности:
1. O(1)— Константная сложность: Алгоритм работает одинаково быстро независимо от размера данных. Пример: Доступ к элементу массива по индексу.
2. O(log(n)) — Логарифмическая сложность: Алгоритм уменьшает объем работы с каждым шагом. Пример: Бинарный поиск (ищем элемент, деля массив пополам).
3. O(n)— Линейная сложность: Время работы увеличивается пропорционально размеру данных. Пример: Проход по массиву, чтобы найти максимальное число.
4. O(n⋅log⁡(n)) — Линейно-логарифмическая сложность: Встречается в эффективных алгоритмах сортировки. Пример: Быстрая сортировка (Quick Sort).
5. O(n^2) — Квадратичная сложность: Время работы увеличивается квадратично с ростом данных. Пример: Сравнение всех пар элементов в массиве.
6. O(2^n) — Экспоненциальная сложность: Каждое добавление данных значительно увеличивает время работы. Пример: Решение задач перебором (все комбинации).

Итог:
1. Big O помогает понять, насколько эффективен наш алгоритм.
2. **Выбирать алгоритмы с меньшей сложностью**, чтобы обработка данных занимала меньше времени.
3. Для маленьких данных сложность не всегда важна, но для больших данных она решает всё