Аторманые (atomic) типы предоставляют возможность выполнять **атомарные операции** над переменными в многопоточном окружении без использования блокировок (например, `synchronized`). Эти классы используют механизм **CAS** (Compare-And-Swap), чтобы гарантировать корректность операций.

Как работает Atomic и CAS:
**CAS** (Compare-And-Swap, "сравнить-и-заменить") — это низкоуровневый механизм, который использует аппаратную поддержку процессора для атомарных операций. Он работает следующим образом:
	1. **Сравнивает** текущее значение переменной с ожидаемым значением.
	2. Если они совпадают, **заменяет** текущее значение на новое.
	3. Если не совпадают, операция завершается неудачно, и её можно повторить.

Пример на практике:
Представьте, что два потока одновременно пытаются изменить переменную:
	1. Переменная `count` равна `5`.
	2. Поток 1 хочет увеличить её на `1`.
	3. Поток 2 тоже хочет увеличить её на `1`.
Если используется **CAS**, то:
1. Поток 1 проверяет: _"Сейчас значение 5?"_ Если да, оно увеличивает до `6`.
2. Поток 2 проверяет: _"Сейчас значение 5?"_ Но теперь значение уже `6`, поэтому поток 2 повторяет попытку.
Это позволяет избежать **состояния гонки** (race condition).

Классы `Atomic`:
1. **`AtomicInteger`**: атомарные операции с `int`.
2. **`AtomicLong`**: атомарные операции с `long`.
3. **`AtomicBoolean`**: атомарные операции с `boolean`.
4. **`AtomicReference`**: атомарные операции с объектами.
5. AtomicStampedReference: предотвращает проблему ABA(описано ниже)

Преимущества CAS:
1. Нет блокировок: Не нужно использовать `synchronized`, что ускоряет работу в многопоточных системах.
2. Высокая производительность: Меньше затрат, чем у `synchronized`, особенно при большом количестве потоков

Недостатки CAS:
1. Проблема ABA: Если значение меняется с `A` на другое значение и обратно на `A`, то CAS может ошибочно считать, что значение не изменилось. Решение: использовать `AtomicStampedReference`, где учитывается версия (метка) значения.
2. Непрерывные повторные попытки (спин): Если много потоков пытаются обновить одну переменную, CAS может тратить ресурсы на повторные попытки.
3. Подходит не для всех задач: CAS хорош для операций над одиночными переменными, но не заменяет сложные механизмы синхронизации.

Когда использовать Atomic и CAS:
1. Когда нужно быстро и безопасно обновлять переменные в многопоточном окружении.
2. Для счетчиков, флагов или индикаторов.
3. Если нужно избежать затрат на блокировки (`synchronized`).

Итог: `Atomic` — это способ выполнять атомарные операции над переменными с использованием CAS. Он гарантирует, что изменения данных будут корректными, даже если несколько потоков работают одновременно. CAS эффективен, но имеет ограничения и подходит для простых сценариев.