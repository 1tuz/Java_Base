Принципы **SOLID** — это пять основных правил, которые помогают писать гибкий, понятный и легко сопровождаемый код.

S - Single Responsibility Principle (Принцип единственной ответственности) - У каждого класса должна быть только одна причина для изменения. 

	Простыми словами: Класс делает только одну задачу. Если что-то нужно поменять, это должно касаться только этой задачи.

	Простой пример: Класс `Invoice` должен заниматься только счетами (например, добавлять товары и считать итог). Если нужно распечатать счёт, эту задачу должен выполнять другой класс, например, `InvoicePrinter`.

	Пример из работы: Когда мы пишем Controller и он отвечает только за принятие запроса и возвращать ответ. В нем не должно быть бизнес-логики, Controller только может вызвать Service, а как раз таки в Service мы пишем, бизнес логику

O - Принцип открытости-закрытости (Open-Closed Principle) – Код должен быть открыт для расширения, но закрыт для модификации.

	Простыми словами: Вы можете добавлять новые функции, не изменяя существующий код.

	Простой пример: У вас есть класс `Shape` (Фигура), а унаследованные классы `Circle` (Круг) и `Rectangle` (Прямоугольник). Если нужно добавить новую фигуру, например, `Triangle` (Треугольник), мы просто создаём новый класс, не меняя существующие

	Пример из работы: Рефакторить все равно приходилось, без этого никак, потому что приходится исправлять баги. Я конечно старался либо второй метод написать, а старый метод багованый пометить аннотацией @Deprecated, но тем не менее рефакторить тоже приходилось. Open/Closed  так и использовав через создание новых классов и методов

L - **Принцип подстановки Барбары Лисков (Liskov Substitution Principle)** – Объекты дочернего класса должны спокойно заменять объекты родительского класса, без ломания логики программы.

	Простыми словами: Если в программе вместо родительского класса вы используете дочерний, всё должно работать как раньше.

	Простой пример: Если у вас есть класс `Bird` (Птица) с методом `fly()`, то подкласс `Penguin` не должен его наследовать, потому что пингвины не летают. Нужно выделить отдельные классы для летающих и нелетающих птиц.

	Пример из работы: Ну тут не знаю, возможно к этому относится что я использовал аннотацию @Qualifier в тоже время у интерфейсов в большинстве случаев одна единственная реализация.
	Второй вариант ответа: У меня не было случаев использования этого принципа

I - **Принцип разделения интерфейса (Interface Segregation** **Principle)** – Интерфейсы должны быть небольшими и специализированными, чтобы классам не приходилось реализовывать ненужные методы.

Простыми словами: Не заставляйте класс делать лишнюю работу. Лучше разбить интерфейс на несколько узких интерфейсов.

Простой пример: Вместо одного большого интерфейса `Worker` с методами `work()`, `eat()`, `sleep()`, создайте несколько интерфейсов:

- `Workable` с методом `work()`
- `Eatable` с методом `eat()`  
    Тогда роботы будут реализовывать только `Workable`, а люди — оба интерфейса.


D -**Принцип инверсии зависимостей (Dependency Inversion** **Principle)** – Зависимости должны строиться от абстракций, а не от конкретных классов. (**модули верхних уровней не должны зависеть от модулей нижних уровней**, а оба типа модулей должны зависеть от абстракций)

	Простыми словами: Не привязывайтесь к конкретным реализациям. Используйте интерфейсы, чтобы можно было легко поменять реализацию.

	Простой пример: Вместо того чтобы класс `NotificationService` зависел от конкретного класса `EmailSender`, он должен зависеть от интерфейса `MessageSender`. Тогда вы можете легко добавить другие реализации, например, `SMSSender` или `PushNotificationSender`.

	Пример из работы: В controller я пишу только принятие запроса и отправка ответа, в repository пишем логику только взаимодействие с базами данных, а service более гибкий нежели другие, то бишь controller вызывает service, service вызывает repository и все они обмениваются DTO
	

1. DRY (Don't Repeat Yourself) — Не повторяйся Принцип DRY заключается в том, чтобы избегать дублирования кода. Это помогает уменьшить количество повторяющихся частей программы, что, в свою очередь, упрощает поддержку и модификацию кода.
2. KISS (Keep It Simple, Stupid) — Держи все просто, глупо Принцип KISS заключается в том, чтобы код был максимально простым и понятным. Сложный код часто приводит к ошибкам и трудностям в его поддержке. Это принцип предостерегает от излишней сложности и избыточных решений.

