![[Pasted image 20241208131531.jpg]]

**Collection** **Framework** – представляет собой набор различных коллекций.

**Коллекция** –  это структура данных, позволяющая хранить в себе набор однородных данных в определенном порядке, и предоставляющая доступ к этим данным. Соответственно, каждая коллекция отличается по своей структуре хранения и предоставления доступа к данным.

**Интерфейс Iterable** – позволяет перебирать элементы коллекции с помощью конструкции for-each, используя специальный объект – итератор.

**Интерфейс Collection** – базовый интерфейс для таких типов коллекция как List, Queue и Set. Определяет основные методы работы с элементами коллекций, которые будут общими для всех его реализаций (например, _size()_, _add(E e)_, _clear()_, методы для работы с StreamAPI - _stream()_, _parallelStream()_ и т.д.). От интерфейса Colecction наследуются следующие коллекции:
1. List (списки) - хранят элементы в определённом порядке, допускают дублирование. 
   Ключевые реализации:
	   1) ArrayList: Динамический массив. Быстрый доступ по индексу. Медленные вставка и удаление в середине. Используется для списков с редким изменением.
	   2) **`LinkedList`**: Реализация на основе двусвязного списка. Быстрая вставка и удаление. Медленный доступ по индексу. Удобен для очередей или списков с частыми изменениями.
2. Set (множества) - Хранят только уникальные элементы.
   Ключевые реализации:
	   1) HashSet: Основан на хэш-таблице. Порядок не гарантируется. Быстрые операции добавления, удаления и поиска.
	   2) **`LinkedHashSet`**: Основан на хэш-таблице и связанном списке. Сохраняет порядок вставки.
	   3) **`TreeSet`**: Основан на дереве (красно-чёрное дерево). Поддерживает упорядоченность элементов.
3. Queue (очереди) - Представляют коллекции для обработки элементов в порядке FIFO (первым пришёл — первым ушёл) или с приоритетами.
   Ключевые реализации:
	   1) **`PriorityQueue`**: Очередь с приоритетами (на основе кучи). Элементы извлекаются в порядке приоритета.
	   2) **`LinkedList`** (как очередь): Используется как обычная очередь.

Обделено стоит структура данных Map (карты), которая не наследует интерфейс Collection. Хранят пары "ключ-значение". Ключи уникальны.
Ключевые реализации:
	1)**`HashMap`**: Основан на хэш-таблице. Быстрый доступ по ключу. Порядок не гарантируется.
	2)**`LinkedHashMap`**: Основан на хэш-таблице и связанном списке. Сохраняет порядок вставки.
	3)**`TreeMap`**: Основан на дереве (красно-чёрное дерево). Хранит ключи в отсортированном порядке.
	4) **`Hashtable`** (устаревший): Потокобезопасная версия `HashMap`.

Почему Map не наследует Collection?
1. **Различие в структуре данных**:
	1) Коллекции (`List`, `Set`) представляют собой контейнеры для хранения элементов.
	2) **`Map`** — это ассоциативный массив, который организован как множество пар ключ-значение.  Если бы `Map` наследовала `Collection`, пришлось бы адаптировать методы, такие как `add`, `remove`, чтобы они обрабатывали пары, что было бы неинтуитивно.
2. **Контекст операций**: 
	   1) У интерфейса `Collection` методы заточены на работу с одиночными элементами (например, `add`, `remove`, `contains`).
	   2) У `Map` другая парадигма: ключ используется для доступа к значению, а методы (`put`, `get`, `remove`) работают с парами.