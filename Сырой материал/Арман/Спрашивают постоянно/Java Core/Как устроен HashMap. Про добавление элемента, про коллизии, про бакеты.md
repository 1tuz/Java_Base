
![[Pasted image 20241208135439.png]]Реализация интерфейса Map, в основе работы которой лежит метод hashcode(). Допускает хранение null ключей и null значений. Не гарантирует порядок отображения элементов. Не синхронизирован. Так же реализует интерфейсы Cloneable и Serializable.

В основе HashMap лежит обычный массив, заполненный структурой данных LinkedList. Экземпляр HashMap имеет два параметра, влияющих на его производительность: _начальную емкость_ – размер массива (обычно равен результату возведения 2 в степень, по умолчанию 16) и _коэффициент загрузки_ – позволяет вычислять, когда будет увеличение размера массива (по умолчанию 0,75). Т.е. при заполнении более 12 ячеек массива (16 * 0,75 = 12), произойдет автоматическое удвоение его размера.

Коэффициент загрузки **0,75** у `HashMap` выбран как компромисс между **памятью** и **производительностью**. Почему именно 0,75?
1. **Коллизии** возникают, когда несколько ключей попадают в одну корзину. Если выбрать коэффициент загрузки выше, например, **0,9**, это приведет к большему числу коллизий, но увеличится эффективность работы памяти.
2. Если выбрать ниже, например, **0,5**, потребуется больше памяти, так как массив будет часто удваиваться, но уменьшится возникновение коллизий.

Ключ – индекс массива, значение – содержимое LinkedList’а. При поиске значения по ключу, сначала высчитывается хэш-код ключа (метод hash() ). Затем высчитывается номер ячейки (индекс массива, еще такую ячейку называют бакетом или корзиной) в которой хранится LinkedList с искомым значением (индекс = (n - 1) & hash, где n – длина массива).

![[Pasted image 20241208140919.png]]

Значения в HashMap хранятся в виде объекта специального внутреннего класса Node, который имеет следующие поля: _final_ _int_ _hash_ – хэш-код текущего элемента; _final_ _K_ _key_ – ключ текущего объекта; _V value_ – значение текущего объекта; _Node<K,V> next_ – ссылка на следующий элемент в текущей корзине

Когда в одной корзине становится 7 или больше записей, а общее количество корзин 64 или больше, то происходит преобразование этой единственной корзины к структуре черно-красного дерева.

**Коллизия** – ситуация при которой отличные друг от друга объекты, выступающие в качестве ключа, попадают в одну корзину. Это может случится если разные объекты имеют одинаковый хэш-код (из-за ограниченности диапазона значений хэш-кода (ограничено типом int = 232), либо из-за плохой реализации хэш-функции), либо из-за малого размера массива (метод, вычисляющий местоположение нужной корзины указывает одно и то же место для объектов с разными хэш-кодами).

Алгоритм действий при добавлении элемента в HashMap:
1.       Проверка ключа на null: если null, то запись идет в ячейку с индексом 0, если там уже есть null, то перезапись на новое значение.
2.       Вычисление хэш-код ключа.
3.       Вычисление индекс массива.
4.       Создание объект Node.

Временная сложность операция HashMap:

	Операции добавления (put), получения (get) и удаления (remove) имеют одинаковую временную сложность. Если хэш-функция равномерно распределяет элементы по корзинам, то в лучшем случае (когда в корзине один элемент) это константное время O(1), а в худшем (когда в корзине красно-черное дерево) не ниже O(log(n)).
	
	Если хэш-функция будет возвращать одно и то же значение для каждого элемента, то все элементы будут добавлять в одну корзину. В итоге получится обычный список LinkedList. В этом случае временная сложность будет O(n).

### **Алгоритм работы метода `put`:**

1. **Проверка на `null`:**
    - Если ключ равен `null`, значение будет помещено в специальную "нулевую корзину" (`bucket`) для `null`. В `HashMap` может быть только один такой ключ.
2. **Вычисление хеш-кода:**
    - Для заданного ключа вычисляется хеш-код с помощью метода `hashCode()`.
    - Хеш-код дополнительно обрабатывается (`hash`) для уменьшения коллизий и равномерного распределения данных.
3. **Определение индекса корзины:**
    - На основе вычисленного хеша и размера таблицы рассчитывается индекс корзины: index=(hash & (capacity−1))
    - Этот индекс указывает, в какую корзину (bucket) поместить ключ-значение.
4. **Поиск существующего ключа:**
    - В выбранной корзине происходит линейный поиск среди её элементов:
        - Если ключ уже существует (определяется с помощью метода `equals`), то:
            1. Старое значение заменяется новым.
            2. Метод завершает работу, возвращая старое значение.
        - Если ключ не найден, продолжаем дальше.
5. **Добавление новой пары:**
    - Если ключ не найден в корзине:
        1. Создаётся новый объект (в виде узла `Node`, содержащего ключ, значение, хеш и ссылку на следующий элемент).
        2. Новый объект добавляется в начало корзины (или конец в случае некоторых реализаций).
6. **Проверка на превышение размера:**
    - Если количество элементов превышает заданный порог (`threshold`), вызывается метод `resize()`, который:
        - Увеличивает размер таблицы.
        - Перераспределяет существующие элементы в новые корзины.


Если два ключа попадают в одну корзину (имеют одинаковый хеш), они хранятся в виде цепочки (`LinkedList`) или дерева (`TreeNode` при превышении порога, обычно 8).