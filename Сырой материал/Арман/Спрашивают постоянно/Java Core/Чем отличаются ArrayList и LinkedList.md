**Класс** ArrayList - представляет собой обычный массив, который автоматически увеличивает свой размер при заполнении.  Это происходит путем копирования данных в новый массив большего размера, а старый удаляется сборщиком мусора. Размер нового массива не регламентирован спецификацией Java и зависит от поставщика JDK (например, для Sun JDK новый размер будет: старый размер * 1,5+1, а стартовый размер массива равен 10).

Если известно, что изначально список будет иметь большой размер, то для уменьшения накладных расходов рекомендуется в конструкторе заранее установить его размер. Если коллекция уже создана, но можно использовать метод _ensureCapacity(int minCapacity)_ – устанавливает минимальную емкость списка.

При удалении элемента происходит сдвиг всех последующих элементов влево и вычитается единица из их индексов. Емкость списка при этом не меняется. При необходимости можно сократить емкость до текущего размера списка с помощью метода _trimToSize()_.

 Реализует интерфейсы: List, Serializable, Cloneable, Iterable, Collection, RandomAccess. Поддерживает хранение null элементов.

Временная сложность операций ArrayList:

	add(E e) – O(1), однако в худшем случае, когда необходимо создать новый массив и скопировать в него все элементы, это O(n) (копирование происходит с помощью native метода System.arraycopy(), который работает быстро, так что в реальности время будет близкое к O(1));

	add(int index, E element) – O(n), сдвигаются все элементы правее;

	get() – O(1), всегда;

	set() – O(1), всегда;

	remove() – O(n), после удаления сдвигает все элементы левее;

	indexOf() – O(n), выполняет итерацию по внутреннему массиву и проверяет каждый элемент;

	contains() – O(n), реализация основана на методе indexOf().

Операция get() всегда имеет время выполнения O(1) потому что на машинном уровне легко вычислить в какой области памяти находятся данные. Данные массива располагаются последовательно в памяти. При создании массива известен его тип данных, а это значит, что известен размер каждой ячейки и всего массива. Следовательно, место хранения элемента: «начальное место массива в памяти» + «размер ячейки» * «размер массива».

Например, имеется массив объектов (в ArrayList хранятся не сами объекты, а ссылки на них, т.е. 4 байта для 32-х бит или 8 байт для 64-х бит). Начальный адрес массива в памяти – 100. Нужен элемент под индексом 8. Нужный элемент будет хранится в ячейке памяти 100 + 4 * 8 = 132. Итого, две арифметические операции + одно обращение к ОЗУ = O(1).


**Класс** LinkedList - Представляет собой двусвязный список. Каждый элемент коллекции содержит в себе: пользовательские данные, индекс, ссылку на предыдущий элемент, ссылку на следующий элемент.

![[Pasted image 20241208151238.png]]

Реализует интерфейсы Queue (FIFO поведение) и Deque (LIFO поведение), благодаря которым данную коллекцию можно использовать как очередь или как стек (также реализует интерфейсы List, Serializable, Cloneable, Iterable, Collection). Поддерживает хранение null элементов.

Операции добавления, удаления, замены происходят с помощью переопределения ссылок у близлежащих элементов. Для поиска нужной ячейки необходимо пройти по всем ссылкам с начала коллекции, то искомого элемента.

Временная сложность операций LinkedList:

                add(E e)_ – O(1), обновляет две ссылки в конце списка;

                add(int index, E element) – O(n), нужно пройти по списку в поисках нужного индекса;

                get() – O(n), нужно пройти по списку в поисках нужного элемента;

                remove() – O(n), перебирается весь лист, чтобы найти элемент, подлежащий удалению;

                remove (index) – O(n), аналогично;

                contains() – O(n), перебор всего списка для поиска элемента.


**ArrayList** vs LinkedList.

![[Pasted image 20241208151411.png]]

ArrayList имеет прямой доступ к памяти, поэтому позволяет быстро обращаться к своим данным и изменять их. Вставка и удаление – медленные операции, т.к. требуют сдвига правой части массива, а при переполнении, копировании данных в новый массив.

LinkedList позволяет быстро производить операции вставки, добавления, удаления за счет переопределения ссылок. Однако из-за медленного поиска нужного элемента (надо пройти по всем ссылкам), скорость данных операций падает до O(n). К тому же LinkedList занимает больше памяти, т.к. помимо данных нужно хранить ссылки на соседние элементы.

В целом LinkedList уступает по всем параметрам ArrayList. По скорости LinkedList выигрывает только тогда, когда операции проводятся с началом списка (примерно 10-20% начальных индексов) или если у нас вставка идет только в начало (метод addFirst() ) и конец (метод addLast() ) LinkedList’а (и то в данном случае стоит рассмотреть ArrayDeque, он работает быстрее, но не позволяет хранить null элементы).

Также ArrayList позволяет быстро удалять группу рядом стоящих элементов с помощью _System.arraycopy()_. Этот метод копирует массив из исходного массива, начиная с указанной позиции, в указанную позицию целевого массива и действует очень быстро, т.к. имеет прямой доступ к памяти и оптимизирован для этой цели. Просто копируется нужная часть массива в новый массив с помощью _subList(int fromIndex, int toIndex)_, а старый массив удаляется сборщиком мусора.


евгений борисов спринг потрошитель