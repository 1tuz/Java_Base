**Проблема N+1 в Hibernate и JPA** — это ситуация, когда для выполнения одного запроса к базе данных (1) требуется множество дополнительных запросов (N) для получения связанных данных. Это приводит к увеличению времени выполнения программы и нагрузке на базу данных.

### Как решить проблему:
1. EntityGraph - использовать **EntityGraph**, чтобы заранее загрузить связанные данные./
   **Как работает:** Указывает Hibernate, какие связанные сущности загружать вместе с основной.
	   Пример:
	   @Entity
		public class Order {
		
		    @ManyToOne(fetch = FetchType.LAZY)
		    private Customer customer;
		}
		
		@Query("SELECT o FROM Order o")
		@EntityGraph(attributePaths = {"customer"})
		List<Order> findAllWithCustomer();
	
    Результат: Генерируется один SQL-запрос с `JOIN`, загружающий заказы и их клиентов.
    
2. JOIN FETCH - использовать `JOIN FETCH` в JPQL для явного запроса связанных данных.
   Как работает: В запросе указывается необходимость загрузить связанные данные.
   Пример:
   @Query("SELECT o FROM Order o JOIN FETCH o.customer")
   List<Order> findAllWithCustomer();
   Результат: Тоже один запрос с `JOIN`.
   
 3. @BatchSize - указывает Hibernate загружать данные партиями, чтобы уменьшить количество запросов.
    Пример:
	@BatchSize(size = 10)
	@OneToMany(mappedBy = "order", fetch = FetchType.LAZY)
	private List<Item> items;

	Результат: Вместо одного запроса на каждый элемент Hibernate загружает по 10 объектов за раз.

4. Загрузка Lazy может частично решить эту проблему, но если потом нам понадобится все равно достать связные данные, то N+1 запрос все равно произойдет и не важно, что было указано Lazy, как бы Lazy только делает отсрочку определенную и также с Lazy есть риск получить LazyInitializationException, если мы попробуем загрузить уже тогда, когда сессия была закрыта.


   