Если мы вызовем метод с аннотацией **@Transactional** из обычного метода того же класса, транзакция не начнётся. Это связано с тем, как Spring использует прокси-объекты для обработки аннотации **@Transactional**.

Почему это происходит:
1. Прокси-объект Spring: Spring создаёт прокси-объект для управления транзакцией. Прокси «оборачивает» вызовы методов и добавляет логику для начала/фиксации/отката транзакции.
2. Вызов изнутри класса: Когда вы вызываете транзакционный метод из другого метода того же класса, вызов происходит напрямую, без участия прокси-объекта. Прокси перехватывает только **внешние вызовы** (когда метод вызывается извне класса, например, из другого бина).

Как исправить?
Если нам нужно, чтобы транзакция начала работать при вызове метода изнутри класса:
1. Рефакторинг: переместите вызов в другой бин: Вынесите транзакционный метод в другой класс, чтобы Spring прокси смог его перехватить.
2. Используйте `@Transactional` на уровне класса: Если вы аннотируете весь класс, транзакция будет начинаться для всех методов, даже при внутренних вызовах.

Итог: Вызов транзакционного метода изнутри класса **обходит Spring-прокси**, из-за чего транзакция не запускается. Решение — вызывать метод извне класса или аннотировать весь класс.