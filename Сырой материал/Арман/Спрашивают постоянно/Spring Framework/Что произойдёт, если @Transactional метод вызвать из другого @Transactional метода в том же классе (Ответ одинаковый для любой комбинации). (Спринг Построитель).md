Если вы вызовете один метод с аннотацией **@Transactional** из другого **@Transactional** метода того же класса, то **новая транзакция не начнётся**. Это связано с тем же механизмом, что и при вызове из обычного метода: вызов происходит напрямую, без участия Spring-прокси.

Почему это происходит:
1. Прокси-объект Spring: Spring создаёт прокси-объект для управления транзакцией. Прокси «оборачивает» вызовы методов и добавляет логику для начала/фиксации/отката транзакции.
2. Вызов изнутри класса: Когда вы вызываете транзакционный метод из другого метода того же класса, вызов происходит напрямую, без участия прокси-объекта. Прокси перехватывает только **внешние вызовы** (когда метод вызывается извне класса, например, из другого бина).

Как исправить?
Если нам нужно, чтобы транзакция начала работать при вызове метода изнутри класса:
1. Рефакторинг: переместите вызов в другой бин: Вынесите транзакционный метод в другой класс, чтобы Spring прокси смог его перехватить.
2. Сделайте вызов через `self` с помощью `@Lazy`:
   @Service
	public class MyService {

	    @Autowired
	    @Lazy
	    private MyService self;
	
	    @Transactional
	    public void outerMethod() {
	        self.innerMethod(); // Вызов через Spring-прокси
	    }
	
	    @Transactional
	    public void innerMethod() {
	        // Операции с базой данных
	    }
	}

Итог: Внутренний вызов транзакционного метода напрямую не создаёт новую транзакцию, так как вызов минует Spring-прокси. Для корректной работы транзакций используйте вызов через другой бин или специальный механизм вроде `self`.
