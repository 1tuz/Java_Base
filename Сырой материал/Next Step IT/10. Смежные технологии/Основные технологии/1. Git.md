### Зачем Git
Необходим для отслеживание изменений в файлах. При работе в команде всегда можно отследить кто и когда какие изменения сделал. После подключения к проекту, гит будет следить за всеми изменениями сделанными в коде. Благодаря этому можно откатить изменения, если они вызвали какие-то ошибки или баги, при этом гит сохранит изменения, которые были откатаны.
### Настройка Git & GitHub
1. Скачиваем git c официального сайта
2. Открываем терминал 
3. Задаем имя пользователя `git config -- global user.name "timur"`
4. Создаем аккаунт на GitHub (специальное приложения, для хранения файлов и истории изменений этих файлов)
### Репозиторий
Это папка с файлами, за которой следит git, любые изменения сделанные в фалах этой папки будут отслеживаться гитом.
- **Локальный репозиторий** - это та папка, которая хранится на локальном компьютере и за которой следит гит 
- **Удаленный репозиторий** - это копия локального репозитория, которая хранится в облаке
**Что нужно чтобы локальный репозиторий добавить в GitHub**
1. Перейти в папку, где находится локальный репозиторий `cd {путь/к_папке/локального/репозитория}`
2. Выполнить команду `git init` - создает локальный репозиторий
3. Создаем новый репозиторий на гитХаб и скопировать url репозитория
4. Выполнить команду `git remote add origin {url удаленного репозитория}`
**Как скачать копию удаленного репозитория**
1. Переходим в папку куда будем качать удаленный репозиторий
2. Запускаем команду `git clone {url удаленного репозитория}` - скачивает все файлы, создавая вашу копию удаленного репозитория
### Коммиты
- `git status` - команда выведет информацию о всех незакоммиченных изменениях в репозитории
- `git add .` - команда подготавливает файлы к следующему коммиту, добавляя их в "индекс" гита. ("Индекс" гита - это хранилище файлов, готовых к коммиту)
- `git commit -m "{message}"` - запоминает версию всех файлов в репозитории из индекса и присваивает ей уникальный код, по которому затем можно вернуться к этой версии
- `git log` - показывает историю всех коммитов, которые были сделаны в ветке, в хронологическом порядке
- `git checkout {хэш-номер коммита}` - возращает файлы к той версии коммита, номер которого указан  
- `git revert {хэш-номер коммита}` - отменяет старый коммит, и создает новый с отменой старого 
- `git reset {тип ресета --soft или --hard} {хэш-номер коммита}` - команда полностью противоположная `git commit`, она расскомичивает изменения из переданных коммитов
### Публикация изменений 
- `git push {имя репозитория (origin)} {имя ветки}` - публикует коммиты из локального репозитория в удаленный с данным именем в данной его ветки
- `git pull {имя репозитория (origin)} {ветка}` - скачивает все коммиты данной ветки, которых еще нет в локальном репозитории
### Ветки
Каждый разработчик создает ветку, при разработке новой фичи, чтобы изолировать свои изменения от основного проекта
- `git branch` - выводит список доступных веток в данном репозитории
- `git branch {имя ветки}` - создает ветку с указанным именем
- `git checkout {имя ветки}` - переходит на указанную ветку
#### Git Flow 
Методология управления ветвлением в системе контроля версий Git, предложенная Винсентом Дриссеном в 2010 году. 
##### Основные компоненты
Git Flow включает в себя несколько ключевых веток, каждая из которых выполняет свою роль:
- **master(main, prod)** - основная ветка, содержащая стабильные версии кода, готовые к релизу
- **develop** - интеграционная ветка, где происходит активная разработка новых функций
- **feature** - ветки для разработки отдельных функций, создаваемые от dev-ветки
- **release** - ветки для подготовки к релизу, создаваемые из dev-ветки, после завершения работы, они сливаются в мастер и дев
- **hotfix** - ветки для срочных исправлений, создаваемые из мастера и сливающиеся в основные ветки
### Слияние
- `git merge {имя ветки}` - производит слияние ветки в ветку, на которой прямо сейчас находится пользователь в виде одного нового коммита в текущую ветку
- `git rebase {имя ветки}` - перемещает коммиты из данной ветки в ту, на которой сейчас находится пользователь 
#### Pull Request и Merge Request
**Pull Request(Merge Request)** - запрос на слияние из вашей ветки в любую другую ветку. 
Изменения в локальном репозитории пушатся на гитХаб и там уже создается запрос на слияние веток. В этот момент не происходит слияние, а только создается запрос, где другие разработчики могут оставлять комментарии к коду. Если другие разработчики подтверждают ваши изменения, то вы можете смержить эту ветку.
### Cherry-pick
Это процесс когда мы можем взять один коммит одной ветки и перенести его в конец другой ветки. 
1. Переключаемся на ветку куда хотим перенести коммит
2. Выполняем команду `git chery-pick {хэш комита}` в этот момент коммит перенесется в конец ветки, в которой сейчас находится пользователь
