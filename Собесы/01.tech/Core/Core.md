#java #Core #многопоточность #Профилирование #jvm 
#### **Потоки и параллелизм**

1. **Базовые концепции:**
    
    - **Thread:** Основной объект для работы с потоками. Он реализует поток выполнения.
    - **Runnable:** Используется для передачи логики потока без необходимости наследовать `Thread`. Более гибкий, так как позволяет разделять логику и управление.
    - **Callable и Future:** Альтернатива `Runnable`, позволяющая возвращать результат выполнения и обрабатывать исключения.
    - **ExecutorService:** Пул потоков, который управляет их созданием и завершением. Это основной инструмент для работы с потоками в современных приложениях.
2. **Управление потоками:**
    
    - **Синхронизация:** Используй ключевое слово `synchronized` для защиты общих ресурсов, но избегай чрезмерного использования, чтобы не создавать блокировки (deadlocks).
    - **ReentrantLock:** Более гибкий механизм блокировок, чем `synchronized`. Позволяет управлять тайм-аутами ожидания блокировки и проверять состояние блокировки.
3. **Concurrent Collections:**
    
    - Используй коллекции из `java.util.concurrent`, такие как `ConcurrentHashMap` и `CopyOnWriteArrayList`, чтобы избежать проблем при доступе из нескольких потоков.
4. **Утилиты для параллелизма:**
    
    - **CountDownLatch:** Ожидает завершения определенного числа задач перед продолжением выполнения.
    - **CyclicBarrier:** Синхронизирует выполнение нескольких потоков в определенных точках.
    - **Semaphore:** Ограничивает количество потоков, одновременно использующих ресурс.
    - **Phaser:** Расширение `CyclicBarrier`, позволяющее динамически добавлять или удалять потоки.
5. **Параллельные потоки (Fork/Join Framework):**
    
    - Этот механизм позволяет эффективно разбирать задачи на подзадачи. Например, для обработки больших массивов данных.
6. **Асинхронные операции:**
    
    - **CompletableFuture:** Современный инструмент для создания асинхронных цепочек операций. Пример: выполнение нескольких задач параллельно, их объединение и обработка результатов.

#### **Оптимизация и профилирование**

1. **Анализ производительности:**
    
    - Для обнаружения проблем используй инструменты профилирования, такие как VisualVM, YourKit или JProfiler.
    - Снимай heap dump для анализа использования памяти и thread dump для диагностики проблем с потоками.
2. **Garbage Collection:**
    
    - Изучи типы сборщиков мусора (G1GC, ZGC, Parallel GC) и их назначение. Например, G1GC хорошо справляется с большими объемами памяти, а ZGC минимизирует паузы.
    - Настраивай параметры GC для оптимизации, например: `-XX:+UseG1GC`, `-XX:MaxGCPauseMillis=200`.
3. **Избегание проблем с памятью:**
    
    - Контролируй утечки памяти через автоматическое закрытие ресурсов (`try-with-resources`).
    - Оптимизируй использование коллекций, чтобы избежать избыточного потребления памяти.

#### **JVM**

1. **Управление памятью:**
    
    - Устанавливай минимальные (`-Xms`) и максимальные (`-Xmx`) размеры heap'а. Например, `-Xms1g -Xmx2g`.
    - Используй `-XX:MetaspaceSize` для управления размером метапространства.
2. **Диагностика JVM:**
    
    - **jmap:** Снимает снимок памяти (`heap dump`) для анализа.
    - **jstack:** Показывает состояние потоков, помогает выявить блокировки или "зависшие" потоки.
    - **jconsole:** Инструмент мониторинга в реальном времени.

Если все понятно, скажи "дальше", и мы перейдем к **Spring Boot и Hibernate**.